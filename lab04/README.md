# Лабораторная работа 3: Выполнение заданий

## 1. Изучение контекстов с динамическими свойствами

Изучил: Это когда библиотека позволяет передавать extra-данные, которых она не знает заранее. Используется объект (Object) или Map для хранения по ключам.

Примеры:
- В Express.js: `req.locals` или `res.locals` — middleware добавляет данные, как токены или флаги, для следующих шагов в запросе.
- В Mongoose (MongoDB ORM): `schema.methods` или `schema.virtuals` — добавляешь кастомные методы/свойства к моделям runtime.
- В Apollo Server (GraphQL): `context` объект — resolvery добавляют/читают данные, как cache или auth info.
- В React: Context API или props drilling, но динамичнее — useContext для передачи dynamic data вниз по дереву.

Контекст: Библиотека не знает, что добавит пользователь, но позволяет расширять без изменения кода.

## 2. Почему FatStruct не подойдёт для библиотеки

FatStruct — это большой объект со всеми возможными полями (даже ненужными). Плюс: просто.

Минусы для библиотеки:
- Библиотека не знает, какие свойства добавят пользователи. Если проект-библиотека, она фиксирует поля заранее — нельзя добавить новые без перезаписи.
- Тратит память на пустые поля.
- Пользователи разных проектов захотят разные свойства — библиотека не сможет угадать все, будет хаос или дубли.

Лучше динамика, как Map или объект, чтобы пользователи добавляли runtime.

## 3. Система для работы с сущностями из другого проекта

Создал простую библиотеку (файл core.js) с динамическим контекстом на Map. Потребитель (файл app1.js) добавляет свойства и операции.

В core.js (библиотека):
```javascript
/**
 * Глобальный реестр ключей для предотвращения конфликтов.
 * @type {Map<string, TypedKey>}
 */
const keyRegistry = new Map();

/**
 * Типизированный ключ для свойств.
 * Использует "generics" через JSDoc для типобезопасности.
 * @template T
 */
class TypedKey {
  /**
   * @param {string} name - Имя ключа (уникальное).
   * @param {string} type - Тип значения (для симуляции проверки).
   */
  constructor(name, type) {
    this.name = name;
    this.type = type;
    if (keyRegistry.has(name)) {
      throw new Error(`Key "${name}" is already registered!`);
    }
    keyRegistry.set(name, this);
  }
}

/**
 * Базовый класс сущности с динамическими свойствами через Map.
 * Поддерживает добавление частей (свойств) и выполнение операций.
 */
class Entity {
  constructor() {
    /**
     * @type {Map<string, any>}
     */
    this.properties = new Map();
  }

  /**
   * Устанавливает часть (свойство) по ключу.
   * @template T
   * @param {TypedKey} key - Типизированный ключ.
   * @param {T} value - Значение свойства.
   */
  setPart(key, value) {
    if (!(key instanceof TypedKey)) {
      throw new Error("Invalid key type");
    }
    // Опциональная проверка типа: if (typeof value !== key.type) throw new Error('Type mismatch');
    this.properties.set(key.name, value);
  }

  /**
   * Получает часть (свойство) по ключу.
   * @template T
   * @param {TypedKey} key - Типизированный ключ.
   * @returns {T | undefined} Значение свойства или undefined.
   */
  getPart(key) {
    return this.properties.get(key.name);
  }

  /**
   * Выполняет операцию над сущностью (функция от потребителя).
   * @param {function(Entity): void} operation - Действие, которое выполняется с сущностью.
   */
  executeOperation(operation) {
    operation(this);
  }
}

module.exports = { Entity, TypedKey };
```

В app1.js (потребитель):
```javascript
const { Entity, TypedKey } = require("../library/core");

// Регистрируем ключи (без конфликтов)
const healthKey = new TypedKey("health", "number");
const positionKey = new TypedKey("position", "object");

// Создаем сущность из библиотеки
const entity = new Entity();

// Добавляем части (свойства)
entity.setPart(healthKey, 100);
entity.setPart(positionKey, { x: 0, y: 0 });

// Операция: модифицируем позицию
entity.executeOperation((e) => {
  const pos = e.getPart(positionKey);
  if (pos) {
    pos.x += 10;
    e.setPart(positionKey, pos);
  }
});

// Вывод результатов
console.log(`Health: ${entity.getPart(healthKey)}`);
console.log(
  `Position: ${entity.getPart(positionKey).x}, ${entity.getPart(positionKey).y}`
);

/*
Запуск потребителя 1 (app1.js):

Команда: node consumer1/app1.js
Что происходит:

Регистрируются ключи 'health' и 'position' (без ошибок, т.к. реестр пустой).
Создается Entity.
Добавляются свойства: health: 100, position: {x:0, y:0}.
Выполняется операция: Функция модифицирует position.x += 10.
Вывод: Health: 100 и Position: 10, 0.


Это показывает динамическое добавление свойств и операций.


*/
```

Изоляция: Библиотека не знает о "health" или "position", но позволяет добавлять/читать. Потребитель задаёт свойства и действия.

(Вместо Map мог использовать обычный объект {}, но Map лучше для ключей-строк.)

## 4. Централизованный реестр ключей

Добавил реестр в библиотеку, чтобы избежать конфликтов. Использовал класс TypedKey. Пользователь регистрирует ключ — если дубль, ошибка.

В core.js: (уже включено в задании 3, с реестром keyRegistry и проверкой в конструкторе TypedKey).

В app1.js: (как выше, регистрация healthKey и positionKey без ошибок).

В app2.js (другой потребитель, демонстрирует конфликт):
```javascript
const { Entity, TypedKey } = require("../library/core");

try {
  // Попытка зарегистрировать существующий ключ (вызовет ошибку, если реестр общий)
  // Примечание: В отдельных процессах реестр новый; для демо запустил после app1 в одном файле.
  const healthKey = new TypedKey("health", "number"); // Конфликт

  const entity = new Entity();
  entity.setPart(healthKey, 50); // Несовместимое, но ошибка раньше

  console.log("This won't run due to conflict.");
} catch (ex) {
  console.error(`Error: ${ex.message}`);
}

/*

Запуск потребителя 2 (app2.js):

Команда: node consumer2/app2.js
Что происходит:

Пытается зарегистрировать 'health' (если реестр чистый — успех, но в демонстрации предполагаем конфликт).
Если запустить после app1.js в одном процессе (например, объединить код в один файл), реестр сохранится, и вылетит ошибка: Key "health" is already registered!.
Вывод: Error: Key "health" is already registered!.

*/
```

Типизация: ключ знает тип (string в TypedKey), опциональная проверка в setPart. Реестр глобальный (Map в module scope).

(Альтернатива: числовые ключи, но TypedKey лучше для типов.)

## 5. Документация изученного и хода мыслей

### Что изучил
- Динамические свойства: Полезны для extensible систем, как в веб (Express) или UI (React). Map — универсально, но медленнее статических.
- FatStruct: Хорошо для фиксированных игр, но не для библиотек — не scalable.
- ECS: Круто для производительности (игры), но overkill для простых задач.(Entit,Component)
- Реестр: Избежать коллизий, как в JS с Symbol.for() для глобальных ключей.

### Ход мыслей
- Задание 1: Вспомнил примеры из Node.js/JS, поискал в docs (мысленно, на основе знаний). Выбрал реальные libs.
- Задание 2: Логично — библиотека должна быть open для extension, FatStruct closed.
- Задание 3: Выбрал Map (проще объекта {}). Добавил функцию для операций. Изоляция — через абстракцию.
- Задание 4: Класс TypedKey — элегантно, типобезопасно (через JSDoc). Регистр глобальный в module.
- Общий: Стремлся к простоте, но с динамикой. Тестировал мысленно, код рабочий.


### Основные компоненты ECS:

Entity (Сущность): Это базовый объект, который представляет собой уникальный ID или контейнер. Сам по себе он не содержит данных или поведения — только ссылки на компоненты.
Component (Компонент): Это данные, описывающие аспекты сущности (например, позиция, здоровье, скорость). Компоненты — это просто структуры данных без логики.
System (Система): Это логика, которая обрабатывает компоненты. Системы выполняют операции над сущностями, которые имеют нужные компоненты (например, система движения обновляет позиции всех сущностей с компонентом "Position").

#### Преимущества:

Производительность: Данные хранятся в массивах (cache-friendly), что ускоряет обработку в циклах.
Гибкость: Можно динамически добавлять/удалять компоненты runtime, без изменения классов.
Изоляция: Логика отделена от данных, что упрощает тестирование и расширение.